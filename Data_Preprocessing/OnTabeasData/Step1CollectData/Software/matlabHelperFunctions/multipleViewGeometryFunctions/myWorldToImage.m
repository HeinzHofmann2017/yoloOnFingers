function [ imagePoints, pointValid ] = myWorldToImage(cameraParams, orientation, location, worldPoints )
%MYWORLDTOIMAGE function to project world-points into the image including
%   of applying distortion to tht image-points
% 
%   Input:
%       cameraParams:   a cameraParameters object
%       orientation:    orientation of camera as [3 x 3] matrix 
%       location:       location of camera as 3-element vector 
%       worldPoints:    3D Worls-points as a [M x 3] array
%       
%   Output:
%       imagePoints:    image points returend as as [M x 2] array
%       pointValid:     logical M-element array that tells, if the
%                       projected image-point is valid
% 

% check input parameters
M = size(worldPoints,1);
if any(size(worldPoints) ~= [M,3])
    error('worldPoints must have size of Mx3')
end
if ( any(size(orientation) ~= [3,3]) )
    error('orientation must be a 3x3-Matrix')
end
if any((size(location) ~= [1,3]) & (size(location) ~= [3,1]))
    error('location must have size of 1x3 or 3x1')
end

% calculate camera matrix
if size(location,1) == 1
    location = location.';
end
rotMat = orientation;
transVec = -rotMat*location;
K = cameraParams.IntrinsicMatrix.';
P = K*[rotMat, transVec];

% Calculate image-points
pointValid = true(M,1);
if all(cameraParams.TangentialDistortion == [0,0])
    imagePoints = worldToImage(cameraParams,rotMat.',transVec.',worldPoints,...
                               'ApplyDistortion', false);
    [ imagePoints, pointValidTemp ] = applyRadialDistortion(imagePoints, K, ...
                                                            cameraParams.RadialDistortion);
    pointValid = pointValid & pointValidTemp;
else
    imagePoints = worldToImage(cameraParams,rotMat.',transVec.',worldPoints,...
                               'ApplyDistortion', true);
end

% undistort image-points
if all(cameraParams.TangentialDistortion == [0,0])
    [ imagePointsUndist, pointValidTemp ] = removeRadialDistortion( imagePoints, K, cameraParams.RadialDistortion);
    pointValid = pointValid & pointValidTemp;
else
    N = size(imagePoints,1);
    imagePointsUndist = NaN(N,2);
    for i=1:N
        imagePointsUndist(i,:) = undistortPoints(imagePoints(i,:), cameraParams);
    end
end

% calculate minimal distance between the world-points and the ray 
% generated by the back-projections of the calculated image-points
[ distance, ~ ] = distanceWorldToRay( worldPoints, imagePointsUndist, P );
pointValid = pointValid & (distance < 1);

end