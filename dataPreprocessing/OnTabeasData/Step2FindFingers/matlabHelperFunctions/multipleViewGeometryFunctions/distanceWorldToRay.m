function [ distance, worldPointsHat ] = distanceWorldToRay( worldPoints, imagePointsUndist, cameraMatrix )
%DISTANCEWORLDTORAY function to calculate the minimal distance between the 
%       world-points and the ray generated by the back-projections of the 
%       image-points
% 
%   Input:
%       worldPoints:        3D World-points as a [N x 3] array
%       imagePointsUndist:  undistorted image points as a [N x 2] array
%       cameraMatrix:       [3 x 4] camera matrix
%       
%   Output:
%       distance:           minimal distance between the world-point and the
%                           ray generated by the back-projection of the image-point
%                           as a [N x 1] array
%       worldPointsHat:     estimation of world-point
% 

% check input parameters
N = size(worldPoints,1);
if any(size(worldPoints) ~= [N,3])
    error('worldPoints must have size of Nx3')
end
if any(size(imagePointsUndist) ~= [N,2])
    error('imagePointsUndist must have size of Nx2')
end
if any((size(cameraMatrix) ~= [3,4]))
    error('cameraMatrix must have size of 3x4')
end

% calculate distance of the world-points to the ray
P = cameraMatrix;
M = P(:,1:3);
camCenter = -inv(M)*P(:,4);
D = inv(M)*[imagePointsUndist,ones(N,1)].';

worldPointsHat = zeros(size(worldPoints));
for i=1:N
    mu = ( D(:,i).'*(worldPoints(i,:).'-camCenter) )/( D(:,i).'*D(:,i) );
    worldPointsHat(i,:) = ( camCenter + mu*D(:,i) ).';
end
distance = sqrt(sum((worldPointsHat-worldPoints).^2,2));


end